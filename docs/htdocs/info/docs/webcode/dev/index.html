<html>
<head>
<title>Web code development</title>
<meta name="order" content="10" />
</head>

<body>

<h1>Introduction to the Ensembl Web Code</h1>

<p>The Ensembl codebase is highly complex, consisting of many hundreds of modules. The 
following notes should help you begin to find your way around!</p>

<ol>
<li><a href="#dirs">Web code directories</a></li>
<li><a href="#routing">URL routing</a></li>
<li><a href="#scripts">Allowed scripts</a></li>
<li><a href="#plugins">Plugins</a></li>
</ol>

<h2 id="dirs">Web code directories</h2>

<p>The following directories contain web-related code:</p>

<dl>
<dt>cbuild</dt>
<dd>inline C code for handling data files</dd>
<dt>conf</dt>
<dd>site-wide configuration files</dd>
<dt>ctrl-scripts</dt>
<dd>Apache startup and stop scripts</dd>
<dt>htdocs</dt>
<dd>general HTML content (e.g. code documentation)</dd>
<dt>modules</dt>
<dd>the main mod_perl codebase used to generate the site</dd>
<dt>perl</dt>
<dd>Perl "CGI" scripts used for some legacy behaviour</dd>
<dt>utils</dt>
<dd>various scripts used to maintain an Ensembl website, e.g. updating content</dd>
</dl>

<div class="info-box" style="padding:10px">
<p> The following directories are typically replicated inside plugins in order to override
"core" functionality:</p>
<ul>
<li>conf</li>
<li>htdocs</li>
<li>modules</li>
</ul>
<p>See <a href="#plugins">plugins</a> (below) for instructions
on how to configure plugins in Ensembl.</p>
</div>

<p>Any other directories in your checkout will contain the Perl API, and after server startup
you will see some additional autogenerated directories used to cache images and other files.</p>

<h3>modules/EnsEMBL/Web</h3>

<p>Most of the web code generated by the Ensembl web team lives in the EnsEMBL::Web namespace.
You will not normally want to edit this code, but you can extend it by replicating the namespace
in your own plugin and adding or overriding methods as required. See 
<a href="/info/docs/webcode/custom/">Extending the Ensembl web code</a> for more details.</p> 

<p>Througout this documentation, EnsEMBL::Web is frequently abbreviated to E::W to save space
and typing!</p>

<h2 id="routing">URL routing</h2>

<p>Ensembl now uses URL routing, that is, URLs do not necessarily correspond to physical
directories but are parsed into their components and passed to a generic script that constructs
an appropriate page.</p>

<p>The exception to this is the static content, i.e. simple HTML pages used to hold
documentation about the site and project - like this page. As a general rule, if the URL
is in lower case, it is static content; if the "directories" have initial capitals, the
page is dynamically generated.</p> 

<p>A typical dynamic URL is shown below:</p>

<blockquote>http://www.ensembl.org/Homo_sapiens/Gene/Summary?g=BRCA2</blockquote>

<p>The URL is split on '/' into the following parts:</p>

<dl>
<dt>Species path</dt>
<dd>Usually just a single "directory", e.g. 'Homo_sapiens', although on some Ensembl-powered sites
such as <a href="http://bacteria.ensembl.org/">EnsEMBL Bacteria</a>, a multi-directory
structure may be used to group closely related species or strains. Other possible values are
'Multi' (for pages that allow access to multiple species' data, e.g. BLAST) or undef (empty) 
if the page is not connected to any species (e.g. user account management).</dd>
<dt>Type</dt>
<dd>This is the type of data being displayed on the page, e.g. Location, Gene, etc for 
genomic data, or Help, Account, etc for general web pages.</dd>
<dt>Action</dt>
<dd>This denotes the particular view or sub-display of the type of data. In our example,
the Action is "Summary", meaning this is the page summarising useful information about the gene.</dd>
<dt>Function</dt>
<dd>This is an optional fourth component of the URL. It is mainly used with interactive code
such as user account management, e.g. /Account/Bookmark/Edit is the URL for the form where
you edit the information stored in a user bookmark.</dd>
</dl>

<p>The parameters after the ? are handled as per normal CGI parameters; in this case, we have
the name of the gene we want to display information about.</p>

<p>The URL is parsed in E::W::Apache::SpeciesHandler - this module should be left well alone 
unless you know exactly what you are doing!</p>

<h2 id="scripts">Allowed scripts</h2>

<p>
In order to determine what type of response a URL requires (full pages, HTML fragments etc.), the Type part of the URL is assigned a script, as follows:
</p>

<dl>
<dt>Page</dt>
<dd>Normal web pages</dd>
<dt>Modal</dt>
<dd>Popup "control panel" (data export, account management)</dd>
<dt>Config</dt>
<dd>A variation on the modal page, used to create the image configuration control panels</dd>
<dt>Component</dt>
<dd>Asynchronously generated page elements (the ones that replace the animated spinner)</dd>
<dt>ZMenu</dt>
<dd>Small popup menus used for contextual navigation</dd>
</dl> 

<p>
This script definition takes place in the <kbd>$OBJECT_TO_SCRIPT</kbd> hash in conf/SiteDefs.pm (which can be extended in your plugin if you want to add data Types to Ensembl):
</p>
<pre class="code">
## ALLOWABLE DATA OBJECTS
$OBJECT_TO_CONTROLLER_MAP = {
  Gene                =&gt; 'Page',
  Transcript          =&gt; 'Page',
  Location            =&gt; 'Page',
  Variation           =&gt; 'Page',
  StructuralVariation =&gt; 'Page',
  Regulation          =&gt; 'Page',
  Marker              =&gt; 'Page',
  GeneTree            =&gt; 'Page',
  Family              =&gt; 'Page',
  LRG                 =&gt; 'Page',
  Phenotype           =&gt; 'Page',
  Experiment          =&gt; 'Page',
  Info                =&gt; 'Page',
  Search              =&gt; 'Page',
  UserConfig          =&gt; 'Modal',
  UserData            =&gt; 'Modal',
  Help                =&gt; 'Modal',
};
</pre>

<p>
The value is then used in E::W::Apache::SpeciesHandler to decide which child of E::W::Controller will be used to process the request.
</p>


<h2 id="plugins">Plugins</h2>

<p>
The Ensembl webcode is designed to be extensible, so that you 
can customize your own installation without your changes being
overwritten when you update to a new release.
</p>
<p>By creating your own plugin, you can completely change the available
species, alter the colour scheme or page template, or add your own views
and static content.</p>

<h3>Public plugins</h3>

<p>A selection of plugins are included as part of the standard Ensembl checkout, enabling you to include optional features in your site.</p>

<p>Most public plugins have a README file giving more detailed and up-to-date information on how to use them.</p>

<dl>
<dt>public-plugins/ensembl</dt>
<dd>Used to configure the current set of Ensembl species (as seen on www.ensembl.org)
- without this or a similar plugin, no data will appear on your site.</dd>
<dt>public-plugins/mirror</dt>
<dd>Used to configure your local server settings</dd>
<dt>public-plugins/genoverse</dt>
<dd>Latest stable version of the Genoverse scrolling browser
<dt>public-plugins/solr</dt>
<dd>Solr search engine</dd>
<dt>public-plugins/tools</dt>
<dd>Web interface for BLAST, VEP, etc</dd>
<dt>public-plugins/tools_hive</dt>
<dd>eHive backend for tools server</dd>
<dt>public-plugins/orm</dt>
<dd>This plugin is used to separate optional features (user accounts, ability to update databases through a web interface) from the core functionality of the Ensembl webcode. It uses Rose::DB::Object and its associated modules for database access, and thus has a lot of additional Perl dependencies</dd>
<dt>public-plugins/admin</dt>
<dd>Administrative interface for non-biological content, such as help and news. Depends on public-plugins/orm</dd>
</dl>

<h3>Using plugins</h3>

<p>Plugins are used to complement the normal system of inheritance in
object-oriented Perl. Whereas a child object can inherit methods
from multiple parents, a parent object normally cannot be overridden by
multiple children. The plugin system "aggregates" the contents
of several methods into one "master" method that can then be used by
mod_perl when rendering the webpage.</p>

<p>The module <code>conf/Plugins.pm</code> controls which plugins are
used by an instance of Ensembl and their order of precedence. In a
standard Ensembl mirror, the module will define a plugin array as follows:</p>

<pre class="code">
$SiteDefs::ENSEMBL_PLUGINS = [
  'EnsEMBL::Mirror'     =&gt; $SiteDefs::ENSEMBL_SERVERROOT.'/public-plugins/mirror',
  'EnsEMBL::Genoverse'  =&gt; $SiteDefs::ENSEMBL_SERVERROOT.'/public-plugins/genoverse',
# 'EnsEMBL::Solr'       =&gt; $SiteDefs::ENSEMBL_SERVERROOT.'/public-plugins/solr',
# 'EnsEMBL::Users'      =&gt; $SiteDefs::ENSEMBL_SERVERROOT.'/public-plugins/users',
  'EnsEMBL::Ensembl'    =&gt; $SiteDefs::ENSEMBL_SERVERROOT.'/public-plugins/ensembl'
  'EnsEMBL::Docs'       =&gt; $SiteDefs::ENSEMBL_SERVERROOT.'/public-plugins/docs',
];
</pre>

<p>The plugins are processed in reverse order, starting with the last one.</p>


<div class="info-box embedded-box"><strong>Important note</strong>: Regardless of any changes you may
make to your Ensembl website, you <em>must</em> check out all the Ensembl Perl API code,
as the web code has extensive dependencies on all the API modules.</div>



</body>
</html>
